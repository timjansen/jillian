JEL Feature by Feature
===========================

JEL is a JavaScript-inspired expression language with a functional design. Unlike most simple expression languages, it supports lambda and you can define constants (but no variables). 


Literals
------------------
1. Strings: can be single-quoted ('foo') or double-quoted ("bar"). Quotes can be escaped with backslashes. Only escape sequences supported are \n and \t.

Examples:
	"foo"
	'bar'
	"it said \"boo\""
	'it said "boo"'
	"Here are some indented lines:\n\tLine1\n\tLine2\n"


2. Numbers: are always floating-point with optional exponential

Examples:
	1
	-1
	2.54
	10.43e-23


3. Fractions: have two integers as numerator and denominator

Examples:
  1/2
  -10/11
  40/20


4. Booleans: true and false

Examples: 
	true
	false


5. Null	

Example:
	null
		
	

Comments
------------------

It supports line comments and blocks.

	42    // the answer
	"foo" /* this is a multi-line comment.
	         It ends here*/


Operators
------------------
It supports JavaScript-like operators. The behaviour of the operator is type-dependent. For basic types it follows JavaScript rules, with the exception that '==' works like '===' (and '!=' like '!==')

Examples:
	3+4
	12-11
	12*15
	8/2
	4+2*3           // returns 10, because of precedence rules
	(4+2)*3         // returns 12
	value == "foo"
  "foo" != value
	!someCondition
	-(4*4)
	cond1 && cond2
	cond1 || cond2
	obj.property   // note that if obj is null, it returns null. No exceptions.
	obj.property > 2 || obj.property < 0
	mul(6, 7)
	obj.print("hello")
	200 +- 10      // Creates an approximate number with an max error of 10



References
------------------
JEL has built-in support for database lookups of named objects.

Examples:
	@Bird    // returns the category Bird
	@Mars    // returns the instance called Mars


Unit Values
-------------
Numbers and Fractions can be used as values with quantity unit. You can also create approximate numbers with units.

Examples:
  2 @Meter
	1/2 @Inch
	2.5 @Second
	1 @Meter +- 5 @Centimeter


Lists
------------------
JEL supports lists, which work like JavaScript Arrays.

Examples:
	[]              // empty lists
	[1,2,3] 
	[a-1, a, a+1]   // expression to create list elements


Dictionary
------------------
Dictionaries are the equivalent of JavaScript's object literals.

Examples:
	{}                            // empty dictionary
  {a: 2, b: "bar", c: 4*5}      // keys following identifier logic do not need to be quoted. Values can be expressions.
	{"a": 2, 'b': 4, 77: "foo"}   // all literals can be keys
  {a}                           // short-cut for {a: a} . Reads the variable "a" and stores it as "a".
	{a, b: 2, c}

Types
------------------
JEL supports complex runtime type checks.

Examples:
  a instanceof string                 // true if a is a non-empty string, false otherwise
  a as string                         // returns a if it is a non-empty string, throws an exception if not
  a instanceof string?                // true if a is a non-empty string or null
  a instanceof Timestamp              // true if a is a Timestamp, false otherwise
  a as Timestamp                      // returns a if it is a Timestamp, throws an exception if not
  a instanceof Timestamp?             // true if a is a Timestamp or null
  a instanceof number                 // true if a is a number (Float or Fraction)
  a instanceof Timestamp|number       // true if a is a Timestamp or a number
  a instanceof Timestamp|number?      // true if a is a Timestamp or a number or null
  a instanceof Timestamp|number|null  // true if a is a Timestamp or a number or null
  a instanceof string[]               // true if a is a List of only strings 
  a instanceof string{}               // true if a is a Dictionary with all values being string
  a instanceof string[]|bool[]        // true if a is either a List of strings or a List of Booleans
  a instanceof (string|bool)[]        // true if a is a List containing only strings and/or Booleans
  a as (string|bool){}                // returns a if a is a Dictionary containing only strings and/or Booleans
  a instanceof @AnimalCategory        // true if a is a Thing in the @AnimalCategory
  a instanceof CategoryType(@AnimalCategory) // true if a is a Category derived from @AnimalCategory (or @AnimalCategory itself)
  a instanceof int                    // true if a is a number representing an integer value
  a instanceof any                    // always true
  a as any                            // always returns any
  a as any[]                          // returns a if a is a List
  a as List                           // returns a if a is a List
  
  

Lambda 
-------------------
Lambda expressions define callable functions.

Examples:
	() => 45      // always returns 45
	a => a*a      // one argument, returns the square number
	(a,b) => a+b  // function thats returns the sum of two arguments
  (a: Number, b: String = "foo") as String => b+a   // Argument types, default value
  (a: String?) => if a then a else ""    // Optional type
	[1, 2, 3].map(e => 2*e)  // returns the list [2, 4, 6]
  



Patterns
-------------------
Patterns are expressions that match a sentence or a phrase. They are somewhat similar to regular expressions, but instead of character-by-character they work word-by-word.
They can embed translators with regular expressions though.

Examples:
	`foot`                      // matches the word 'foot'
	`he went away`              // matches the sentence 'he went away'
	`[it|he|she] walked away`   // matches the sentences 'it walked away', 'he walked away' and 'she walked away'
	`he [quickly]? walked away`   // matches the sentences 'he walked away' and 'he quickly walked away'
	`he [slowly|quickly]? walked away`   // matches the sentences 'he walked away', 'he quickly walked away' and 'he slowly walked away'
	`he went {{destination}}`            // matches the words 'he went' and then calls a Translator called 'destination' for the third
	`my name is {{n: name}}`             // uses the Translator 'name', and returns the translator's result as variable 'n'
	`my favorite color is {{col: color}}`      
	`I like {{a: animal.plural}}`        // specifies that only Translator matches with the meta property 'plural' are used
	`I like {{a: animal.plural :: @Bird.isCategoryOf(a)}}`        // conditional translator usage: limits matches to instances of @Bird
  `This is number {{n: /[0-9]+/ :: Number.parse(n) > 0}}`       // Regular expression match
  `{{date: /([0-9]+)-([0-9]+)-([0-9]+)/ }}`                     // RE with groups: returns a List containing the three numbers
  `{{date: /[0-9]+/ /[0-9]+/ /[0-9]+/ }}`                       // Three REs, to match three words. Also returns list.



Translators
-------------------
Translators are a special kind of dictionaries that use Patterns instead of keys, and use Lambda expressions instead of a value. The lambda expressions get the Pattern template values as
arguments. They can have one or more meta properties.

Examples:
	${`one` => 1, `two` => 2}}
	${verb: `walk` => Walking(), 
	  verb, tense="past": `walked`=> Walking(past=true), 
		verb: `run` => Running()}


Conditions
-------------------
JEL supports simple if/then/else expressions. The 'else' part can be omitted, it defaults to 'true'. This is mainly useful for inferences (if something is true, 
something else is true as well).

Examples:
	if a==12 then 'a dozen' else 'not a dozen'
	if a==0 then 'none' else if a<10 then 'a few' else 'a lot'
	if @Frog.isCategoryOf(a) then a.capabilities.includes(@Jumping)
	

With Constants
-------------------
With allows you to define constants that can be used in the following expression.

Examples:
	with a=2: a+3   // returns 5
	with x=1, y=x+2, z=y*3: z*4   // returns 36
	
	
Classes
---------
The 'class' keyword allows you to set up a class that can be stored in the database:

class Schedule::Single extends Schedule::Entry {
  c: Number
  static PI = 3.14

  constructor(a: number, b: number, c: number): // arguments are automatically stored as properties in the object!
    super(a, b)+                                // calling super(), which returns a Dictionary of property values to set
    {sum: a+b+c}                                // return a Dictionary to store additional fields or overwrite argument values
  
  get x() as number:
    this.c+2
  
  add(a, b):
    this.c+a+b

  addWithTypes(a: number, b: number) as number: 
    this.c+a+b

  static add(x,y):
    x+y
}



 
  
TODO: 
	

