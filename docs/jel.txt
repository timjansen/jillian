JEL Feature by Feature
===========================

JEL is a TypeScript-inspired expression language with a functional design. 


Literals
------------------
1. Strings: are double-quoted ("foo") by default. Quotes can be escaped with backslashes. Only escape sequences supported are \n and \t.
(You can also use single-quotes, but these are actually string templates, not literals, see below)

Examples:
	"foo"
	"it said \"boo\""
	"Here are some indented lines:\n\tLine1\n\tLine2\n"


2. Numbers: are always floating-point with optional exponential

Examples:
	1
	-1
	2.54
	10.43e-23


3. Fractions: have two integers as numerator and denominator

Examples:
  1/2
  -10/11
  40/20


4. Booleans: true and false

Examples: 
	true
	false


5. Null	

Example:
	null


String Templates
--------------------
Single-quoted strings ('bar') are string templates. Unlike double-quoted strings, they can contain sub-expressions in double curly braces that will be computed at runtime and then inserted
into the string. If you don't have a sub-expression in the single-quoted string, it behaves like a double-quoted one.

Examples:
	'1+2 is {{1+2}}'        // prints "1+2 is 3"
	'{{a}} is {{a%2==0}}'   



Lists
------------------
JEL supports lists, which work like JavaScript Arrays.

Examples:
	[]              // empty lists
	[1,2,3] 
	[a-1, a, a+1]   // expression to create list elements


Dictionary
------------------
Dictionaries are the equivalent of JavaScript's object literals.

Examples:
	{}                            // empty dictionary
  {a: 2, b: "bar", c: 4*5}      // keys following identifier logic do not need to be quoted. Values can be expressions.
	{"a": 2, 'b': 4}              // all string literals can be keys
	{'b_{{name}}': 1}             // string templates are supported for keys. In the case of an name clash, the last one wins.
  {a}                           // short-cut for {a: a} . Reads the variable "a" and stores it as "a".
	{a, b: 2, c}


Comments
------------------

It supports line comments and blocks.

	42    // the answer
	"foo" /* this is a multi-line comment.
	         It ends here*/


Operators
------------------
It supports JavaScript-like operators. The behaviour of the operator is type-dependent. For basic types it follows JavaScript rules, with the exception that '==' works like '===' (and '!=' like '!==')

Examples:
	3+4
	12-11
	12*15
	8/2
	4+2*3           // returns 10, because of precedence rules
	(4+2)*3         // returns 12
	value == "foo"
  "foo" != value
	!someCondition
	-(4*4)
	cond1 && cond2
	cond1 || cond2
	obj.property   // note that if obj is null, it throws an exception
	obj.?property  // returns null if obj is null
	obj.property > 2 || obj.property < 0
	mul(6, 7)
	obj.print("hello")   // throws an exception if obj is null
	obj.?print("hello")  // returns null if obj is null
	200 +- 10      // Creates an approximate number with an max error of 10
  1...10         // Creates a range of 1...10 (inclusive)
  >=1            // Creates a range from 1 (inclusive) to infinity
  <=6            // Creates a range with a max of 6 (inclusive)
  >1             // Creates a range from 1 (exclusive) to infinity
  <6             // Creates a range with a max of 6 (exclusive)
  >1...<3        // Creates a range of 1 (exclusive) ...3 (exclusive)
  1...<10        // Creates a range of 1 (inclusive) ...10 (exclusive)
  a in 1...10    // true if a>=1 and a<=10
  a in >1...<10  // true if a>1 and a<10
  a in [1, 2, 3] // true if a==1, a==2 or a==3
  a in {a: 1, b: 2} // true as dictionary contains a



References
------------------
JEL has built-in support for database lookups of named objects.

Examples:
	@Bird    // returns the category Bird
	@Mars    // returns the instance called Mars


Unit Values
-------------
Numbers and Fractions can be used as values with quantity unit. You can also create approximate numbers with units.

Examples:
  2 @Meter
	1/2 @Inch
	2.5 @Second
	1 @Meter +- 5 @Centimeter   // 1 Meter with a tolerance of 5 centimeters



Types
------------------
JEL supports complex runtime type checks using instanceof.

Examples:
  a instanceof string                 // true if a is a non-empty string, false otherwise
  a instanceof string?                // true if a is a non-empty string or null
  a instanceof Timestamp              // true if a is a Timestamp, false otherwise
  a instanceof Timestamp?             // true if a is a Timestamp or null
  a instanceof number                 // true if a is a number (Float or Fraction)
  a instanceof number(1...10)         // true if a is a number between 1 and 10 (inclusive)
  a instanceof 1...10                 // true if a is a number between 1 and 10 (inclusive, regardless of the type)
  a instanceof 1 @Meter ... 10 @Meter // true if a is a unit value compatible with meters between 1 and 10 meters
  a instanceof Timestamp|number       // true if a is a Timestamp or a number
  a instanceof Timestamp|number?      // true if a is a Timestamp or a number or null
  a instanceof Timestamp|number|null  // true if a is a Timestamp or a number or null
  a instanceof string[]               // true if a is a List of only strings 
  a instanceof string{}               // true if a is a Dictionary with all values being string
  a instanceof number<>               // true if a is a number or a Range of numbers
  a instanceof string[]|bool[]        // true if a is either a List of strings or a List of Booleans
  a instanceof (string|bool)[]        // true if a is a List containing only strings and/or Booleans
  a instanceof @AnimalCategory        // true if a is a Thing in the @AnimalCategory
  a instanceof CategoryType(@AnimalCategory) // true if a is a Category derived from @AnimalCategory (or @AnimalCategory itself)
  a instanceof int                    // true if a is a number representing an integer value
  a instanceof int(>=0)               // true if a is a positive integer
  a instanceof any                    // true if a is not null
  a instanceof any?                   // always true


Types
------------------
JEL supports casts, which are mainly used to check type, but will also allow limited conversion.

Examples:
  a as string                         // returns a if it is a non-empty string, throws an exception if not
  a as Timestamp                      // returns a if it is a Timestamp, throws an exception if not
  a as (string|bool){}                // returns a if a is a Dictionary containing only strings and/or Booleans
  a as int[]                          // returns a if a is a List of integers, an empty list if a is null, or a list containing a if a is an integer. Otherwise it throws an exception.
  a as any[]                          // returns a if a is a List, an empty list if a is null, and a list containing only a otherwise
  a as List                           // returns a if a is a List


  

Lambda 
-------------------
Lambda expressions define callable functions.

Examples:
	() => 45      // always returns 45
	a => a*a      // one argument, returns the square number
	(a,b) => a+b  // function thats returns the sum of two arguments
  (a: Number, b: String = "foo"): String => b+a   // Argument types, default value
  (a: String?) => if a then a else ""    // Optional type
	[1, 2, 3].map(e => 2*e)  // returns the list [2, 4, 6]
  (...a: any[])=>a.length  // varargs



Patterns
-------------------
Patterns are expressions that match a sentence or a phrase. They are somewhat similar to regular expressions, but instead of character-by-character they work word-by-word.
They can embed translators with regular expressions though.

Examples:
	`foot`                      // matches the word 'foot'
	`he went away`              // matches the sentence 'he went away'
	`[it|he|she] walked away`   // matches the sentences 'it walked away', 'he walked away' and 'she walked away'
	`he [quickly]? walked away`   // matches the sentences 'he walked away' and 'he quickly walked away'
	`he [slowly|quickly]? walked away`   // matches the sentences 'he walked away', 'he quickly walked away' and 'he slowly walked away'
	`he went {{destination}}`            // matches the words 'he went' and then calls a Translator called 'destination' for the third
	`my name is {{n: name}}`             // uses the Translator 'name', and returns the translator's result as variable 'n'
	`my favorite color is {{col: color}}`      
	`I like {{a: animal.plural}}`        // specifies that only Translator matches with the meta property 'plural' are used
	`I like {{a: animal.plural :: @Bird.isCategoryOf(a)}}`        // conditional translator usage: limits matches to instances of @Bird
  `This is number {{n: /[0-9]+/ :: Number.parse(n) > 0}}`       // Regular expression match
  `{{date: /([0-9]+)-([0-9]+)-([0-9]+)/ }}`                     // RE with groups: returns a List containing the three numbers
  `{{date: /[0-9]+/ /[0-9]+/ /[0-9]+/ }}`                       // Three REs, to match three words. Also returns list.



Translators
-------------------
Translators are a special kind of dictionaries that use Patterns instead of keys, and use Lambda expressions instead of a value. The lambda expressions get the Pattern template values as
arguments. They can have one or more meta properties.

Examples:
	${`one` => 1, `two` => 2}}
	${verb: `walk` => Walking(), 
	  verb, tense="past": `walked`=> Walking(past=true), 
		verb: `run` => Running()}


Conditions
-------------------
JEL supports simple if/then/else expressions. The 'else' part can be omitted, it defaults to 'true'. This is mainly useful for inferences (if something is true, 
something else is true as well).

Examples:
	if a==12 then 'a dozen' else 'not a dozen'
	if a==0 then 'none' else if a<10 then 'a few' else 'a lot'
	if a then a else false                                  // a is true unless it is a boolean false or null
	if @Frog.isCategoryOf(a) then a.capabilities.includes(@Jumping)
	

Constants
-------------------
'let' allows you to define constants that can be used in the following expression.

Examples:
	let a=2: a+3   // returns 5
	let x=1, y=x+2, z=y*3: z*4+x   // returns 37
	

Assertions
-------------------
'with' allows you to define assertions that will be checked before the child expression has been executed. If the assertions fail, an exception will be thrown.
Assertions are mostly meant to be used at the top of class methods, to document and check any assertions made.

Examples:
	with a>=b, b>0, a>0: a/b
	with a in 0...16: a/16
  
	
Classes
---------
The 'class' keyword allows you to set up a class that can be stored in the database:

class Schedule::Single extends Schedule::Entry:
  c: Number
  static PI = 3.14

  constructor(a: number, b: number, c: number) => // arguments are automatically stored as properties in the object!
    super(a, b)+                                  // calling super(), which returns a Dictionary of property values to set
    {sum: a+b+c}                                  // return a Dictionary to store additional fields or overwrite argument values
  
  get x(): number =>
    this.c+2
  
  add(a, b) =>
    this.c+a+b

  addWithTypes(a: number, b: number): number =>
    this.c+a+b

  divWithTypes(a: number, b: number): number =>
    with b!=0:
      a/b


  static add(x,y) =>
    x+y

  addMany(...a: number[]) =>                       // To create a varargs method, declare the last parameter as array and prepend the name with '...'
    a.reduce((x, acc)=>x+acc, 0)


Enums
--------
You can define simple enums with the 'enum' operator:

enum FactType:
  Sample,
  Definition,
  Guess
  





