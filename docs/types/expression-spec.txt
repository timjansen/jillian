// Expressions
// ===========
//
//  Expressions are objects that can be evaluated. Expressions always have a default object (instance or category).
// 
//  The following objects are possible:
//
//  Operator:
//  { 
//     type: 'operator',
//     operator: '<name>' // operator name here
//     // Parameters:
//     // 'left'/'right' for 2 parameter operators
//     // 'operand' for 1 parameter operators
//  }
//
//  Literals: 
//  {
//     type: 'literal',
//     value: 42   // explicit syntax, e.g. for passing objects
//  }
//
//  List: (4, 5, 8)
//  {
//     type: 'list',
//     value: [42]   // array of one or more values
//  }
//
//  Properties: (a.b)
//  {
//     type: 'property',
//     name: '<propertyName>',     // uses default object if no ref given
//  }
//
//  Relationships: (a.*b short for a.relationships.b)
//  {
//     type: 'relationships',
//     name: '<name>',         // uses default object if no ref given
//  }
//
//  References: (@a)
//  {
//     type: 'reference',
//     name: 'a'
//  }
//
//  Variables reference:
//  {
//     type: 'variable',
//     name: 'a'
//  }
//
//  Calls: ( a.b() )
//  {
//     type: 'call',
//     left: <expression>,
//     argList: [],                    // optional: list of arguments
//     argNames: {}                    // optional: named arguments
//  }
//
//  Lambda: (a=>b or (a,b)=>c)
//  {
//     type: 'lambda',
//     args: ['<names>'],          // variable names
//     expression: <expression>    // the expression / term
//  }
//
//  Conditions: (if a then b else c)
//  {
//     type: 'condition',
//     condition: <expression>,  // the expression to execute. Evaluated to boolean using JS rules.
//     then: <expression>     ,  // what to return if the expression was true. Default: the condition's return value.
//     else: <expression>        // what to return if the expression was false. 
//  }
//
//  Const Assignment: with x: 4+4, y:6+6 => c
//  {
//     type: 'with',
//     assignments: [{name: '<name>', expression: <expression>}],  // order is important, because expressions may access previous variable names
//     expression: <expression>
//  }
//
//  List: ( [1, 'foo', f()] )
//  {
//     type: 'list',
//     elements: [<expression>..]
//  }
//

// Operators
// ---------

// Comparison operators with values in 'left'/'right'. 'left' and 'right' can be lists. The first value that is not undefined is taken.
// Checks values within accuracies. e.g. {value: 100, accuracy: 2}={value: 103, acccuracy: 2}
// When using locations, equal is true if one operand is within another / the geoposition matches. A location is smaller if it is contained in the other location.
// '=', '<', '>', '>=', '<=', '!='

// Like above, but ignores accuracy. {value: 100, accuracy: 2}!=={value: 103, acccuracy: 2}
// '==', '<<', '>>', '>==', '<==', '!=='

// Logical operators with several 'operands'. Boolean conversion follows Java standards.
// '&&', '||'

// Logical operators with 'operand':
// '!' ('operand' only)

// Special operator 'instanceof' ('left'/'right'): checks whether instance 'left' is an instance of category 'right', using category property (directly or indirectly)
// Special operator 'derivativeof' ('left'/'right'): checks whether instance 'right' is based on the instance 'left' (this is for objects derived objects, especially in different realities)

// Algorithmic operators with 'left'/'right': '+', *', '/', '&'. Work with numbers, prices.

// Difference operator with 'left'/'right': '-'
// Can work with numbers, time (return diff in ms), calendar date (return diff in days), geopositions (return diff in meters), prices (same currency?)

// Other operators: 'abs' (absolute value). Works with numbers.


// Examples
// -----------
{
			operator: 'AND',
			operands: [{
						operator: '>',
						left: {property: 'instant'},
						right: {literal: {year: 1980, month: 1, day: 1}}
			}, {
						operator: '<',
						left: {property: 'instant'},
						right: {property: 'time', ref: '@Now'}
			}]
}
