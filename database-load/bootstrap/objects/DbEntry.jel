/**
 * Base type for database entries with properties.
 */
native class DbEntry:
  native constructor(distinctName: string, 
               facts: Fact[]{} = {},
               reality: thing?,               // <<< TODO
							 hashCode: string?)

  // evaluate dependencies
  private getDependencies(fact: Fact, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): any{}? => 
    if fact.dependencies.isEmpty then {}
    if excludedProperties && !fact.dependencies.findCommon(excludedProperties).isEmpty then null

    let r = fact.dependencies.mapToDictionary(prop=>metaProperties[prop] || this.getBestDiscreteValue(prop, currentTime, metaProperties, excludedProperties=fact.dependencies.addAll(excludedProperties)).?value):
      if r.hasAny((k,v)=>v==null) then 
        null
       else 
        r.setAll(metaProperties).set('currentTime', currentTime)

  /**
   * Checks whether the given value is possible for the fact.
   */
   // TODO: better algorithm
  checkValue(name: string, currentTime: time, value: any): bool =>
    this.getBestFacts(name, currentTime).until(f=>f.comprehensive, true).map(f=>f.checkValue(value).xor(f.negative)).reduce((v, i)=>Boolean.falsest(v, i), true)    


  /**
   * Returns all facts with the given name that are relevant to this DbEntry. On Categories, it will be just the list of direct facts. On Things, it will be Thing's own facts plus the Category facts.
   */
  getAllFacts(name: string): Fact[] => (this.facts.get(name) || [])


  getFilteredFacts(name: string, filter: function((element: any?, index: int(>=0))=>any?)?, max: int(>=0)?): Fact[] =>
    let sorted = this.getAllFacts(name).sort(key='trustLevel', desc=true):
      if filter then sorted.filter(filter, max) 
      else if max != null then sorted.subLen(length=max)
      else sorted


  getBestFacts(name: string, currentTime: time, metaProperties: any{}?, max: int(>=0)?, excludedProperties: Set?): Fact[] =>
    this.getFilteredFacts(name, filter = f=>(if currentTime && f.startTime then f.startTime <= currentTime) &&
                          (if currentTime && f.endTime then f.endTime > currentTime) && 
                          (
                            let deps = this.getDependencies(f, currentTime, metaProperties, (excludedProperties || Set.empty) + name):
                              deps != null && if f.precondition then f.precondition.call(deps)
                          ),
                          max = max)

  getBestFactResults(name: string, currentTime: time, metaProperties: any{}?, max: int(>=0)?, excludedProperties: Set?): FactResult[] =>
    this.getBestFacts(name, currentTime, metaProperties, null, excludedProperties)
      .filter(f=>!f.negative)
      .map(f=>let r = f.getValue(this.getDependencies(f, currentTime, metaProperties, (excludedProperties || Set.empty) + name)):
        if r != null then FactResult(f, r) else null)
      .filterNull()
      .subLen(length=max)

  /**
   * Returns the best fact result with the given name. Maybe a Range or Distribution... use getBestDiscreteValue() if you need a discrete value.
   */
  getBestFactResult(name: string, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): FactResult? => 
    this.getBestFactResults(name, currentTime, metaProperties, 1, excludedProperties)[0]

  /**
   * Returns the best value that has the fact type, and is not a describing fact like a Range or Distribution.
   */
  getBestDiscreteValue(name: string, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): FactResult? => 
    this.getBestFacts(name, currentTime, metaProperties, null, excludedProperties)
      .filter(f=>!f.negative)
      .map(f=>let r = f.getDiscreteValue(this.getDependencies(f, currentTime, metaProperties, (excludedProperties || Set.empty) + name)):
        if r != null then FactResult(f, r) else null)
      .filterNull()[0]
      

