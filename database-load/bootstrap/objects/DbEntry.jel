/**
 * Base type for database entries with properties.
 */
native class DbEntry:
  native constructor(distinctName: string, 
               facts: FactList{} = {},
               reality: thing?,               // <<< TODO
							 hashCode: string?)


  // evaluate dependencies
  private getDependencies(fact: Fact, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): any{}? => 
    if fact.dependencies.isEmpty then {}
    if excludedProperties && !fact.dependencies.findCommon(excludedProperties).isEmpty then null

    let r = fact.dependencies.mapToDictionary(prop=>metaProperties[prop] || this.getBestSingleValue(prop, time, metaProperties, excludedProperties=fact.dependencies.setAll(excludedProperties))):
      if r.hasAny((k,v)=>v==null) then 
        null 
       else 
        r.setAll(metaProperties).set('currentTime', currentTime)

  // evaluate condition
  private checkPrecondition(fact: Fact, deps: any{}): bool => 
    if fact.precondition then fact.precondition.call(deps)


  getBestFacts(name: string, currentTime: time, metaProperties: any{}?, max: int(>=0)?, excludedProperties: Set?): Fact[] =>
    let fl = this.facts.get(name):
      if !fl then 
        if name == 'matchesInYear' && this.distinctName=='Meter' then [['Looking for matchesInYear in '+this.distinctName, this.facts]] else []//[]
      else
        fl.getBestFacts(filter = f=>(if f.startTime then f.startTime <= currentTime) &&
                                    (if f.endTime then f.endTime > currentTime) && 
                                    (
                                      let deps = this.getDependencies(f, currentTime, metaProperties, excludedProperties):
                                        deps != null && this.checkPrecondition(f, deps)
                                    ),
                       max = max)


  getBestValues(name: string, currentTime: time, metaProperties: any{}?, max: int(>=0)?, excludedProperties: Set?): FactResult[] =>
    this.getBestFacts(name, currentTime, metaProperties, null, excludedProperties)
      .map(f=>let r = f.getValue(this.getDependencies(f, currentTime, metaProperties, excludedProperties)):
        if r != null then FactResult(f, r) else null)
      .filterNull()
      .subLen(length=max)

  getBestValue(name: string, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): FactResult? => 
    this.getBestValues(name, currentTime, metaProperties, 1, excludedProperties)[0]

  getBestSingleValue(name: string, currentTime: time, metaProperties: any{}?, excludedProperties: Set?): FactResult? => 
    this.getBestFacts(name, currentTime, metaProperties, null, excludedProperties)
      .map(f=>let r = f.getSingleValue(this.getDependencies(f, currentTime, metaProperties, excludedProperties)):
        if r != null then FactResult(f, r) else null)
      .filterNull()
      .subLen(length=max)

